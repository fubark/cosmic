<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style>
        html, body {
            margin: 0px;
            background-color: #333333;
        }
        canvas {
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script src="./stdx.js"></script>
    <script src="./graphics.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const wasm = {
            imports: {
                env: {
                    memset: function(ptr, val, size) {
                        const wasm_view = new Uint8Array(wasm.exports.memory.buffer);
                        for (let i = 0; i < size; i++) {
                            wasm_view[ptr + i] = val;
                        }
                        return ptr;
                    },
                    memcpy: function(dst, src, size) {
                        const wasm_view = new Uint8Array(wasm.exports.memory.buffer);
                        for (let i = 0; i < size; i++) {
                            wasm_view[dst + i] = wasm_view[src + i];
                        }
                        return dst;
                    },
                    __assert_fail(assertion, file, line, func) {
                        console.log('__assert_fail')
                    },
                    __stack_chk_fail() {
                        console.log('__stack_chk_fail')
                    },
                    strcmp() {
                        throw new Error('TODO: Implement libc strcmp.')
                    },
                    strncmp() {
                        throw new Error('TODO: Implement libc strncmp.')
                    },
                    strtol() {
                        throw new Error('TODO: Implement libc strtol.')
                    },
                },
                graphics: {},
                stdx: {},
            },
            exports: {},
            inputPtr: 0,
            inputCap: 0,
            inputLen: 0,
        };
        wasm.imports.graphics = initGraphicsImports(wasm, canvas);
        wasm.imports.stdx = initStdxImports(wasm);

        // First checks that local view of the input buffer has enough space.
        // If not, tells wasm to increase the buffer. Local view is updated afterwards.
        function ensureFreeCapacity(num_bytes) {
            if (wasm.inputLen + num_bytes > wasm.inputCap) {
                const ptr = wasm.exports.ensureFreeCapacity(num_bytes)
                let view = new DataView(wasm.exports.memory.buffer)
                wasm.inputPtr = view.getUint32(ptr, true)
                wasm.inputCap = view.getUint32(ptr + 4, true)
            }
        }

        const KeyDownCommand = 1;
        const KeyUpCommand = 2;
        const MouseDownCommand = 3;
        const MouseUpCommand = 4;
        const MouseMoveCommand = 5;
        const WindowResizeCommand = 6;

        // Load wasm.
        const wasmFile = 'demo.wasm';
        fetch(wasmFile)
            .then(resp => resp.arrayBuffer())
            .then(buf => WebAssembly.instantiate(buf, wasm.imports))
            .then(res => {
                wasm.exports = res.instance.exports;
                // console.log(wasm);
                const ptr = wasm.exports.wasmInit();
                processWasmResult(ptr);
                initApp();
            });

        function initApp() {
            window.addEventListener('mousedown', function(e) {
                ensureFreeCapacity(7)
                var cur_ptr = wasm.inputPtr + wasm.inputLen
                const view = new DataView(wasm.exports.memory.buffer)
                view.setUint8(cur_ptr, MouseDownCommand)
                view.setUint8(cur_ptr+1, e.button)
                view.setInt16(cur_ptr+2, e.clientX, true)
                view.setInt16(cur_ptr+4, e.clientY, true)
                view.setUint8(cur_ptr+6, e.detail)
                wasm.inputLen += 7
            })
            window.addEventListener('mouseup', function(e) {
                ensureFreeCapacity(7)
                var cur_ptr = wasm.inputPtr + wasm.inputLen
                const view = new DataView(wasm.exports.memory.buffer)
                view.setUint8(cur_ptr, MouseUpCommand)
                view.setUint8(cur_ptr+1, e.button)
                view.setInt16(cur_ptr+2, e.clientX, true)
                view.setInt16(cur_ptr+4, e.clientY, true)
                view.setUint8(cur_ptr+6, e.detail)
                wasm.inputLen += 7
            })
            window.addEventListener('mousemove', function(e) {
                ensureFreeCapacity(5)
                var cur_ptr = wasm.inputPtr + wasm.inputLen
                const view = new DataView(wasm.exports.memory.buffer)
                view.setUint8(cur_ptr, MouseMoveCommand)
                view.setInt16(cur_ptr+1, e.clientX, true)
                view.setInt16(cur_ptr+3, e.clientY, true)
                wasm.inputLen += 5
            })
            window.addEventListener('keydown', function(e) {
                // console.log('keydown', e.code, e.which, e.key);
                ensureFreeCapacity(5)
                var cur_ptr = wasm.inputPtr + wasm.inputLen
                const view = new DataView(wasm.exports.memory.buffer)
                view.setUint8(cur_ptr, KeyDownCommand)
                view.setUint16(cur_ptr+1, e.which, true)
                let mod = 0
                if (e.shiftKey) {
                    mod |= 8
                }
                if (e.ctrlKey) {
                    mod |= 4
                }
                if (e.altKey) {
                    mod |= 2
                }
                if (e.metaKey) {
                    mod |= 1
                }
                view.setUint8(cur_ptr+3, mod)
                view.setUint8(cur_ptr+4, e.repeat)
                wasm.inputLen += 5
            });
            window.addEventListener('keyup', function(e) {
                // console.log('keyup', e.code, e.which, e.key, e.shiftKey);
                ensureFreeCapacity(4);
                var cur_ptr = wasm.inputPtr + wasm.inputLen
                const view = new DataView(wasm.exports.memory.buffer)
                view.setUint8(cur_ptr, KeyUpCommand)
                view.setUint16(cur_ptr+1, e.which, true)
                let mod = 0
                if (e.shiftKey) {
                    mod |= 8
                }
                if (e.ctrlKey) {
                    mod |= 4
                }
                if (e.altKey) {
                    mod |= 2
                }
                if (e.metaKey) {
                    mod |= 1
                }
                view.setUint8(cur_ptr+3, mod)
                wasm.inputLen += 4
            })
            window.addEventListener('resize', function() {
                // A bit smaller so it doesn't trigger scrollbars in the browser page.
                resize(window.innerWidth-4, window.innerHeight-4)
            })
            // Initially resize to the window size.
            resize(window.innerWidth-4, window.innerHeight-4)
            window.requestAnimationFrame(loop)
        }

        function resize(width, height) {
            wasm.imports.graphics.jsSetCanvasBuffer(width, height)
            ensureFreeCapacity(5)
            var cur_ptr = wasm.inputPtr + wasm.inputLen
            const view = new DataView(wasm.exports.memory.buffer)
            view.setUint8(cur_ptr, WindowResizeCommand)
            view.setUint16(cur_ptr+1, width, true)
            view.setUint16(cur_ptr+3, height, true)
            wasm.inputLen += 5
        }

        const target_fps = 60;
        const target_ms_per_frame = 1000 / target_fps;
        // Since there is no sleep logic, we add up time to see if we should perform a frame update.
        // Sometimes we could miss the target_ms_per_frame by a little and as a result affect the fps greatly,
        // so we have a minimum target instead.
        const min_ms_per_frame = target_ms_per_frame / 2;

        let last_time_ms = performance.now();

        // App loop.
        function loop(now_ms) {
            const req_id = window.requestAnimationFrame(loop);
            const delta_ms = now_ms - last_time_ms;
            if (delta_ms >= min_ms_per_frame) {
                last_time_ms = now_ms;
                // Perform app update after reaching target ms.
                try {
                    const ptr = wasm.exports.wasmUpdate(now_ms, wasm.inputLen);
                    processWasmResult(ptr);
                } catch (e) {
                    // Report error and stop the loop.
                    console.error(e);
                    window.cancelAnimationFrame(req_id);
                }
            }
        }

        function processWasmResult(ptr) {
            // Must create a view directly over the buffer (slices won't allow writing to the original buffer)
            let view = new DataView(wasm.exports.memory.buffer)
            wasm.inputPtr = view.getUint32(ptr, true)
            wasm.inputCap = view.getUint32(ptr + 4, true)
            wasm.inputLen = 0;
        }
    </script>
</body>
</html>