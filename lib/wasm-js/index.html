<html>
<head>
    <style>
        html, body {
            margin: 0px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script src="./stdx.js"></script>
    <script src="./graphics.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const wasm = {
            imports: {
                graphics: {},
                stdx: {},
            },
            exports: {},
            inputPtr: 0,
            inputCap: 0,
            inputLen: 0,
        };
        wasm.imports.graphics = initGraphicsImports(wasm, canvas);
        wasm.imports.stdx = initStdxImports(wasm);

        // Load wasm.
        const wasmFile = 'demo.wasm';
        fetch(wasmFile)
            .then(resp => resp.arrayBuffer())
            .then(buf => WebAssembly.instantiate(buf, wasm.imports))
            .then(res => {
                wasm.exports = res.instance.exports;
                // console.log(wasm);
                const ptr = wasm.exports.wasmInit();
                processWasmResult(ptr);
                window.requestAnimationFrame(loop);
            });

        const target_fps = 60;
        const target_ms_per_frame = 1000 / target_fps;
        // Since there is no sleep logic, we add up time to see if we should perform a frame update.
        // Sometimes we could miss the target_ms_per_frame by a little and as a result affect the fps greatly,
        // so we have a minimum target instead.
        const min_ms_per_frame = target_ms_per_frame / 2;

        let last_time_ms = performance.now();

        // App loop.
        function loop(now_ms) {
            const req_id = window.requestAnimationFrame(loop);
            const delta_ms = now_ms - last_time_ms;
            if (delta_ms >= min_ms_per_frame) {
                last_time_ms = now_ms;
                // Perform app update after reaching target ms.
                try {
                    const ptr = wasm.exports.wasmUpdate(now_ms, wasm.inputLen);
                    processWasmResult(ptr);
                } catch (e) {
                    // Report error and stop the loop.
                    console.error(e);
                    window.cancelAnimationFrame(req_id);
                }
            }
        }

        function processWasmResult(ptr) {
            // Must create a view directly over the buffer (slices won't allow writing to the original buffer)
            let wasmBufferView = new DataView(wasm.exports.memory.buffer);
            wasm.inputPtr = wasmBufferView.getUint32(ptr, true);
            wasm.inputCap = wasmBufferView.getUint32(ptr + 4, true);
            wasm.inputLen = 0;
        }
    </script>
</body>
</html>